---

typora-copy-imgs-to: img
---

### **一、JVM 简介**

**三种JVM**
	**JVM是一种设计规范，落地的是Java HotSpot**
	**第一种：Sun公司的HotSpot**
	**第二种：BEA公司(tomcat就是该公司旗下)的JRockit**
	**第三种：IBM公司的J9 VM**

1.![1559829720706](img\1559829720706.png)



![1559829861631](img\1559829861631.png)



****

#### **1.JVM是运行在操作系统之上的，它与硬件没有直接的交互**	

#### **2.jvm结构**  :**按照淘宝中成名《jvm规范》的说法，jvm优化99%优化堆，1%优化方法区**

##### **1)Class Loader 类加载器**

```
	负责加载class文件，class文件在开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至  于它是否可以运行，则由Execution Engine决定 		
```

##### **2)Native Interface 本地接口**

```
	本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记native方法，在Execution Engine执行时加载navtive libraies.
 	目前该方法使用的越来越少了，除非 是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见。
 	因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。
```



##### **3)运行时数据区【重要】** 

##### **栈管运行，堆管存储【重要】**



######   **方法区：**

```xaml
 <-- 方法区是被所有线程共享>，所有字段和方法字节码，以及一些特殊方法如构造函数（方法区主要放的是构造方法+接口的代码），接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区属于共享区间。
 <-- 静态变量+常量+类信息+运行时常量池存在方法区中+实例变量存在堆内存中/>
 【JVM优化的共享区】
```

   

######  **栈：**

```
一.
	1.Native Method Stack 本地方法栈
    	它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native  		libraies。    
 	2.Execution Engine 执行引擎负责解释命令，提交操作系统执行。
 	3.Runtiome data area 运行数据区

二.Stack 栈是什么
	栈也叫栈内内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over,生命周期和线程一致，是线程私有的。基本类型的变量和对象的引用变量都是在函数的栈内存中分配。
	1)栈存储什么？
    栈帧中主要保存3类数据：
        本地变量(Local variables):输入参数和输出参数以及方法内的变量；
        栈操作(Operand Stack):记录出栈、入栈的操作；
        栈帧数据(Frame Data):包括类文件、方法等等。
    2)栈运行原理
    栈中的数据都是以栈帧(Stack Frame)的格式存在，栈帧是一个内存块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3也被压入栈...执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧...
   栈主要是要为了正确释放线程资源(栈释放 )。 
   3)递归，死循环调用会报异常:StackOverflowError
   
```



###### **程序计数器**：

```xaml

 <每个线程都有一个程序计数器/>，就是一个指针，指向方法区中的方法字节码(下一个将要执行的指令代码)，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
 
 注：程序计数器的特点
　　1.线程隔离性，每个线程工作时都有属于自己的独立计数器。
　　2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址。
　　  <-- 
      JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。
　　从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。
　　首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。
　　
 
```



###### 堆：---JVM优化的就是堆

![1559898850434](img\1559898850434.png)

![1559898872400](img\1559898872400.png)



**1. 新生代：**

```xaml
   新生代是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。
   <-- 新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace）/-->
   所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。那如果1 区也满了呢？再移动到养老代。若养老代也满了，那么这个时候将产生MajorGC（FullGC），进行养老代的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。【Minor GC和Major GC是重点】
    如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：
. Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。【最大是内存的1/4】
	System.out.println(Runtime.getRuntime().maxMemory()/1024/1024);
    byte[] bytesArray = new byte[1*1024*1024*2000];
    System.out.println("good");
. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。
```



 **2. 养老代：**

```xml
 <- 养老区用于保存从新生区筛选出来的JAVA对象，一般池对象都在这个区域活跃。/->
```



 **3. 永久代(java7之前有，java8以后改名为元空间：**

       永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。
       如果出现java.lang.OutOfMemoryError:PermGen space,说明是Java虚拟机对永久代内存设置不够。一般出现这种情况都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用，或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。

![1559886819378](img\1559886819378.png)

![1559886908405](img\1559886908405.png)









#### 3.GC回收

> ​    **.GC是什么**
> ​	**. 频繁收集Young区**
> ​	**. 较少收集Old区**
> ​	**. 基本不动Perm区**

------



##### **1.年轻代(伊甸园区+两个幸存区)**     **-----   Eden+Survior(From)+Survior(To)**

年轻代用的是Minor **GC**

![1559921087879](img\1559921087879.png)

![1559921103759](img\1559921103759.png)

##### 2.老年代一般是由标记清除或者是标记清除与标记整理的混合家现

###### 标记清除/标记整理算法: FullGC 又叫MajorGC（全局GC)

![1559922686530](img\1559922686530.png)



###### GC三大算法概述：

```

	1)GC算法总体概述
	JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分为两种类型，一种是普通GC(minor GC),一种是全局GC(major GC or Full GC)
	普通GC(minor GC):只针对新生代区域的GC
	全局GC(major GC):针对老年代的GC,偶尔伴随对新生代的GC以及对永久代的GC
	
	2)复制算法：MinorGC(普通GC)
	普通GC(minor GC):只针对新生代区域的GC
		. 年轻代使用的是Minor GC,这种GC算法采用的是复制算法(Copying)
		          
	3)标记清除/标记整理算法：FullGC又叫做MajorGC(全局GC)
	①老年代一般是由标记清理与标记整理的混合实现
	②标记清除(Mark-Sweep)
		. 原理：
		标记(Mark):从根集合开始扫描，对存活的对象进行标记
		清除(Sweep):扫描整个内存空间，回收未被标记的对象，使用free-list记录可以清除的区域。
			1.不需要额外空间
			2.两次扫描，耗时严重
			3.会产生内存碎片
		. 劣势:
        	1.首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲
         	2.第二点主要的缺点，则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。
	③标记整理(Mark-Compact)
		. 原理：
            Before GC:  AeeBeeAeAA
            After GC:   ABAAA
		. 劣势
            标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。
	
	4)小总结
		内存效率：复制算法>标记清除算法>标记整理算法 (仅仅对比时间复杂度)
		内存整齐：复制算法=标记整理算法>标记清除算法
		内存利用率：标记整理算法=标记清除算法>复制算法
        
        可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。

       难道就没有一种最优算法吗？
 	   答：无，没有最好的算法，只有最合适的算法(套话)
 	   	  目前GC算法中的神级算法:分代搜集算法。

	
```



##### 3.GC面试题：

```

1.GC-5 (面试题)
	1)StackOverflowError 和 OutOfMemoryError,谈谈你的理解
	2）一般什么时候会发生GC?如何处理？
	答：Java中的GC会有两种回收：年轻代的Minor GC，另外一个就是老年代的Full GC；新对象创建的时候如果伊甸园空间不足会触发Minor GC,如果此时老年代的内存空间不足会触发Full GC,如果空间都不足则抛出OutOfMemoryError.
	3)GC回收策略，谈谈你的理解
	答：年轻代(伊甸园区+两个幸存区)，GC回收策略为“复制”；
	老年代的保存空间一般较大，GC回收策略为“整理，压缩”；      

2.百度GC面试题
		1.JVM内存模型以及分区，需要详细到每个区放什么
		2.堆里面的分区:Eden,survival from to,老年代，各自的特点
		3.GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，优化收集方法的思路。
		4.MinorGC与Full GC分别在什么时候发生
```



### 二. 硬件 - 系统 - jvm 

#### 1.硬件层面

**CPU和缓存一致性(处理器---系统--计算机的存储设备)**

　　由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲。

**那么，程序的执行过程就变成了：**

**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。**

　

​	随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：**缓存一致性（Cache Coherence）**。

**1.**单线程、cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。

**2.单核CPU，多线程。**进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。

**3.多核CPU，多线程。**多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。

​	　在多核处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。

![1559990166211](img\1559990166211.png)

![1560000306383](img\1560000306383.png)



#### 2.Java内存模型

**1.概念：Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。**

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为线程创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图：

![1559991725576](img\1559991725576.png)

　　**线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。**



**2.内存间交互操作：**

　　**关于主内存与工作内存之间的具体交互协议(Java内存模型（JMM）)，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型（JMM）定义了以下八种操作来完成：**

🔊

- **lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。**
- **unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。**
- **read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用**
- **load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。**
- **use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。**
- **assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。**
- **store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。**
- **write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。**

------

　如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

------



#### 3.Java内存区域与Java内存模型关系

**Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范。**

**Java内存区域可以视作是Java内存模型的实现**

![1560001017971](img\1560001017971.png)



**图上的私有数据区就是Java内存模型(JMM)所描述的 工作内存**

**图上的共享数据区就是Java内存模型(JMM)所描述的 主内存**



#### 4.**Java线程与硬件处理器**  ---  既JVM和硬件处理器CPU

​		了解完硬件的内存架构后，接着了解JVM中线程的实现原理，理解线程的实现原理，有助于我们了解Java内存模型与硬件内存架构的关系，在Window系统和Linux系统上，Java线程的实现是基于一对一的线程模型，所谓的一对一模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。这里需要了解一个术语，内核线程(Kernel-Level Thread，KLT)，它是由操作系统内核(Kernel)支持的线程，这种线程是由操作系统内核来完成线程切换，内核通过操作调度器进而对线程执行调度，并将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身,这也就是操作系统可以同时处理多任务的原因。由于我们编写的多线程程序属于语言层面的，程序一般不会直接去调用内核线程，取而代之的是一种轻量级的进程(Light Weight Process)，也是通常意义上的线程，由于每个轻量级进程都会映射到一个内核线程，因此我们可以通过轻量级进程调用内核线程，进而由操作系统内核将任务映射到各个处理器，这种轻量级进程与内核线程间1对1的关系就称为一对一的线程模型。如下图： 

![1560002589413](img\1560002589413.png)







![1560071718887](img\1560071718887.png)

